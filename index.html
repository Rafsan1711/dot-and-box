<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dot & Box Online Multiplayer with Bot</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"></script>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #121212;
      color: #eee;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      margin: 0;
    }
    #auth-screen, #app {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 0 20px;
    }
    #auth-screen {
      background: #1f1f1f;
    }
    button {
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:focus {
      outline: none;
    }

    #game-board {
      margin: 20px auto;
      display: grid;
      gap: 4px;
      max-width: 100vw;
      touch-action: manipulation;
      user-select: none;
    }
    .dot {
      width: 12px;
      height: 12px;
      background-color: #eee;
      border-radius: 50%;
      pointer-events: none;
    }
    .line {
      background-color: #555;
      cursor: pointer;
      transition: background-color 0.3s;
      border-radius: 3px;
      box-sizing: border-box;
    }
    .line.horizontal {
      height: 6px;
      width: 50px;
    }
    .line.vertical {
      height: 50px;
      width: 6px;
    }
    .line.active {
      cursor: default;
    }
    .line.player-1 {
      background-color: #4a90e2;
    }
    .line.player-2 {
      background-color: #e94e77;
    }
    .line.player-3 {
      background-color: #f5a623;
    }
    .line.player-4 {
      background-color: #7ed321;
    }
    .box {
      width: 50px;
      height: 50px;
      background-color: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2em;
      color: #eee;
      user-select: none;
      border-radius: 4px;
      transition: background-color 0.3s;
    }
    .box.player-1 {
      background-color: #4a90e2;
    }
    .box.player-2 {
      background-color: #e94e77;
    }
    .box.player-3 {
      background-color: #f5a623;
      color: #000;
    }
    .box.player-4 {
      background-color: #7ed321;
      color: #000;
    }

    #player-list {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
      flex-wrap: wrap;
      user-select: none;
    }
    .player-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      font-size: 1.1em;
      color: #ccc;
      min-width: 100px;
      justify-content: center;
    }
    .player-circle {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background-color: gray;
      box-shadow: 0 0 5px transparent;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      flex-shrink: 0;
    }
    .player-turn {
      transform: scale(1.3);
      box-shadow: 0 0 10px 4px currentColor;
      color: inherit;
    }

    #status {
      margin-top: 12px;
      font-weight: 700;
      font-size: 1.3em;
      min-height: 30px;
      user-select: none;
      text-align: center;
    }

    #winner-message {
      margin-top: 20px;
      font-weight: 800;
      font-size: 1.6em;
      color: #0f0;
      user-select: none;
    }

    #btn-restart {
      margin-top: 25px;
      padding: 12px 24px;
      background: #333;
      border-radius: 8px;
      font-weight: 700;
      color: #eee;
      border: none;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s;
    }
    #btn-restart:hover {
      background: #4a90e2;
      color: #fff;
    }

    #match-info {
      margin-top: 10px;
      font-size: 0.9em;
      color: #6cf;
      user-select: text;
      word-break: break-word;
      max-width: 100vw;
      text-align: center;
    }

    /* Modal */
    #modal {
      position: fixed;
      inset: 0;
      background-color: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 15px;
    }
    #modal.active {
      display: flex;
    }
    #modal-content {
      background: #222;
      padding: 24px 30px;
      border-radius: 8px;
      text-align: center;
      max-width: 400px;
      color: #eee;
    }
    #modal-content p {
      margin-bottom: 22px;
      font-size: 1.2em;
    }
    #modal-buttons {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    #modal-buttons button {
      flex: 1;
      min-width: 120px;
      padding: 10px 0;
      font-weight: 700;
      border-radius: 6px;
      border: none;
      font-size: 1em;
      user-select: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #modal-btn-continue {
      background-color: #4a90e2;
      color: white;
    }
    #modal-btn-continue:hover {
      background-color: #357ABD;
    }
    #modal-btn-cancel {
      background-color: #e94e77;
      color: white;
    }
    #modal-btn-cancel:hover {
      background-color: #b23050;
    }

    /* Responsive tweaks */
    @media (max-width: 640px) {
      .line.horizontal {
        width: 40px;
        height: 5px;
      }
      .line.vertical {
        height: 40px;
        width: 5px;
      }
      .box {
        width: 40px;
        height: 40px;
        font-size: 1em;
      }
      #player-list {
        gap: 12px;
      }
      .player-item {
        min-width: 80px;
        font-size: 1em;
      }
    }
  </style>
</head>
<body>

  <!-- Authentication Screen -->
  <div id="auth-screen" class="flex flex-col items-center justify-center">
    <h1 class="text-4xl font-bold mb-8">Dot & Box Online</h1>
    <button id="btn-signin" class="bg-blue-600 px-8 py-3 rounded hover:bg-blue-700 font-semibold">
      Sign in with Google
    </button>
  </div>

  <!-- Main App -->
  <div id="app" class="hidden flex flex-col items-center flex-grow max-w-5xl mx-auto w-full">

    <!-- Header: username, mode buttons, sign out -->
    <header class="w-full flex flex-wrap items-center justify-between gap-2 px-4 py-3 bg-gray-900 rounded-md mt-4">
      <div class="text-lg text-blue-400 font-semibold select-text" id="user-info">Loading...</div>
      <div class="flex gap-2 flex-wrap">
        <button id="btn-mode-2" class="px-4 py-2 rounded bg-green-600 hover:bg-green-700 font-semibold">
          2 Players
        </button>
        <button id="btn-mode-4" class="px-4 py-2 rounded bg-purple-600 hover:bg-purple-700 font-semibold">
          4 Players
        </button>
        <button id="btn-continue-bot" class="px-4 py-2 rounded bg-blue-500 hover:bg-blue-600 font-semibold">
          Continue with Bot
        </button>
      </div>
      <button id="btn-signout" class="px-4 py-2 rounded bg-red-600 hover:bg-red-700 font-semibold">
        Sign Out
      </button>
    </header>

    <!-- Match info -->
    <div id="match-info" class="select-text mt-3"></div>

    <!-- Players & turn indicator -->
    <div id="player-list" aria-live="polite" role="list"></div>

    <!-- Game status -->
    <div id="status" role="status" aria-live="polite" class="mt-3"></div>

    <!-- Game board -->
    <div id="game-board" class="mt-4"></div>

    <!-- Winner message -->
    <div id="winner-message" class="mt-6"></div>

    <!-- Restart button -->
    <button id="btn-restart" class="hidden mx-auto">Restart Game</button>

    <!-- Leaderboard -->
    <section id="leaderboard-container" class="mt-10 w-full max-w-md">
      <h2 class="text-2xl font-semibold mb-4 text-center">Leaderboard</h2>
      <div id="leaderboard" class="space-y-2 max-h-64 overflow-y-auto rounded-md bg-gray-900 p-4"></div>
    </section>

  </div>

  <!-- Modal for bot confirmation -->
  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-desc">
    <div id="modal-content">
      <p id="modal-desc">Do you want to <strong>Continue with Bot</strong> if opponents don't join?</p>
      <div id="modal-buttons">
        <button id="modal-btn-continue" aria-label="Continue with Bot">Continue with Bot</button>
        <button id="modal-btn-cancel" aria-label="Cancel">Cancel</button>
      </div>
    </div>
  </div>

<script>
  // Firebase config (Replace with your config)
  const firebaseConfig = {
    apiKey: "AIzaSyCKfr-jvUKonc2TcEDcejk562kOm8LTAa0",
    authDomain: "dot-and-box-online.firebaseapp.com",
    databaseURL: "https://dot-and-box-online-default-rtdb.firebaseio.com/",
    projectId: "dot-and-box-online",
    storageBucket: "dot-and-box-online.appspot.com",
    messagingSenderId: "334340725862",
    appId: "1:334340725862:web:356b78d59e76ff6f5861a7"
  };

  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.database();

  // Game settings
  const boardSize = 7; // 7x7 boxes (feel free to change for difficulty)
  let currentUser = null;
  let currentMode = 2; // 2 or 4 players
  let isBotMode = false;
  let gameActive = false;
  let players = [];
  let currentTurn = 0;
  let lines = new Set();
  let scores = {};
  let slotRef = null;
  let slotCode = null;
  let slotListener = null;
  let isGameOver = false;

  // Cached DOM
  const authScreen = document.getElementById('auth-screen');
  const app = document.getElementById('app');
  const btnSignIn = document.getElementById('btn-signin');
  const btnSignOut = document.getElementById('btn-signout');
  const btnMode2 = document.getElementById('btn-mode-2');
  const btnMode4 = document.getElementById('btn-mode-4');
  const btnContinueBot = document.getElementById('btn-continue-bot');
  const userInfo = document.getElementById('user-info');
  const matchInfo = document.getElementById('match-info');
  const playerListDiv = document.getElementById('player-list');
  const statusDiv = document.getElementById('status');
  const gameBoard = document.getElementById('game-board');
  const winnerMessage = document.getElementById('winner-message');
  const btnRestart = document.getElementById('btn-restart');
  const modal = document.getElementById('modal');
  const modalBtnContinue = document.getElementById('modal-btn-continue');
  const modalBtnCancel = document.getElementById('modal-btn-cancel');

  // Helpers
  function generateCode() {
    return (Math.floor(1e7 + Math.random() * 9e7)).toString();
  }

  // Firebase rating update helper
  async function updateUserRating(uid, change) {
    const ref = db.ref('users/' + uid);
    const snap = await ref.get();
    let rating = snap.child('rating').exists() ? snap.child('rating').val() : 1000;
    rating += change;
    await ref.update({ rating });
  }

  // Sign In
  btnSignIn.addEventListener('click', () => {
    const provider = new firebase.auth.GoogleAuthProvider();
    auth.signInWithPopup(provider);
  });

  // Sign Out
  btnSignOut.addEventListener('click', async () => {
    await auth.signOut();
    resetApp();
  });

  auth.onAuthStateChanged(user => {
    if (user) {
      currentUser = user;
      authScreen.classList.add('hidden');
      app.classList.remove('hidden');
      userInfo.textContent = `Hello, ${user.displayName}`;
      loadLeaderboard();
      resetGame();
    } else {
      currentUser = null;
      app.classList.add('hidden');
      authScreen.classList.remove('hidden');
      userInfo.textContent = 'Loading...';
      clearSlot();
    }
  });

  // Clear slot listener & ref if any
  function clearSlot() {
    if (slotListener && slotRef) {
      slotRef.off('value', slotListener);
      slotListener = null;
      slotRef = null;
    }
    slotCode = null;
    players = [];
    currentTurn = 0;
    gameActive = false;
    isBotMode = false;
    lines.clear();
    scores = {};
    winnerMessage.textContent = '';
    matchInfo.textContent = '';
    playerListDiv.innerHTML = '';
    statusDiv.textContent = '';
    gameBoard.innerHTML = '';
    btnRestart.classList.add('hidden');
  }

  // Reset game & UI for new session or mode change
  function resetGame() {
    clearSlot();
    currentTurn = 0;
    lines = new Set();
    scores = {};
    gameActive = false;
    winnerMessage.textContent = '';
    matchInfo.textContent = '';
    statusDiv.textContent = '';
    players = [];
    btnRestart.classList.add('hidden');
    renderPlayerList();
    createBoard();
  }

  // Render player list with turn indicator & color
  function renderPlayerList() {
    playerListDiv.innerHTML = '';
    const colors = ['#4a90e2', '#e94e77', '#f5a623', '#7ed321'];
    players.forEach((uid, idx) => {
      const div = document.createElement('div');
      div.className = 'player-item';
      div.style.color = colors[idx];
      div.textContent = uid === currentUser.uid ? 'You' : 'Player ' + (idx + 1);
      const circle = document.createElement('span');
      circle.className = 'player-circle';
      circle.style.backgroundColor = colors[idx];
      if (idx === currentTurn) circle.classList.add('player-turn');
      div.prepend(circle);
      playerListDiv.appendChild(div);
    });
  }

  // Update status text & color
  function updateStatus() {
    if (!gameActive) {
      statusDiv.textContent = '';
      return;
    }
    const names = ['Blue', 'Red', 'Yellow', 'Green'];
    statusDiv.textContent = `Player ${currentTurn + 1}'s turn (${names[currentTurn]})`;
    statusDiv.style.color = ['#4a90e2', '#e94e77', '#f5a623', '#7ed321'][currentTurn];
  }

  // Create game board DOM grid
  function createBoard() {
    gameBoard.innerHTML = '';
    const size = boardSize * 2 - 1;
    gameBoard.style.gridTemplateColumns = `repeat(${size}, auto)`;
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (r % 2 === 0 && c % 2 === 0) {
          // dot
          const dot = document.createElement('div');
          dot.className = 'dot';
          gameBoard.appendChild(dot);
        } else if (r % 2 === 0 && c % 2 === 1) {
          // horizontal line
          const line = document.createElement('div');
          line.className = 'line horizontal';
          line.dataset.r = r;
          line.dataset.c = c;
          line.addEventListener('click', onLineClick);
          gameBoard.appendChild(line);
        } else if (r % 2 === 1 && c % 2 === 0) {
          // vertical line
          const line = document.createElement('div');
          line.className = 'line vertical';
          line.dataset.r = r;
          line.dataset.c = c;
          line.addEventListener('click', onLineClick);
          gameBoard.appendChild(line);
        } else {
          // box
          const box = document.createElement('div');
          box.className = 'box';
          box.dataset.r = r;
          box.dataset.c = c;
          gameBoard.appendChild(box);
        }
      }
    }
    updateStatus();
  }

  // On line click handler
  function onLineClick(e) {
    if (!gameActive || isGameOver) return;

    const line = e.currentTarget;
    if (line.classList.contains('active')) return; // already taken

    const key = `${line.dataset.r},${line.dataset.c}`;
    if (lines.has(key)) return;

    // Mark line
    lines.add(key);
    line.classList.add('active', `player-${currentTurn + 1}`);
    line.style.cursor = 'default';

    // Check boxes completed
    let completedBoxes = markBoxes(line.dataset.r | 0, line.dataset.c | 0, currentTurn + 1);

    // Update scores
    if (!scores[currentTurn]) scores[currentTurn] = 0;
    scores[currentTurn] += completedBoxes;

    renderBoxes();
    renderPlayerList();
    updateStatus();

    if (checkGameOver()) return;

    // If completed boxes, current player plays again
    if (completedBoxes === 0) {
      currentTurn = (currentTurn + 1) % players.length;
      renderPlayerList();
      updateStatus();
    }

    if (isBotMode && players[currentTurn] === 'bot') {
      setTimeout(botPlay, 1000);
    }

    // Save to Firebase
    saveGameState();
  }

  // Mark boxes around the line, return count of boxes completed this move
  function markBoxes(r, c, playerNum) {
    let completed = 0;
    // For boxes, the coordinates are odd, odd (r,c)
    // The line coords are even/odd or odd/even

    // Check box on the "top/left" side
    let boxesToCheck = [];
    if (r % 2 === 0) {
      // horizontal line, check boxes above and below
      if (r > 0) boxesToCheck.push([r - 1, c]);
      if (r < boardSize * 2 - 2) boxesToCheck.push([r + 1, c]);
    } else {
      // vertical line, check boxes left and right
      if (c > 0) boxesToCheck.push([r, c - 1]);
      if (c < boardSize * 2 - 2) boxesToCheck.push([r, c + 1]);
    }

    boxesToCheck.forEach(([br, bc]) => {
      if (isBoxCompleted(br, bc)) {
        const boxKey = `${br},${bc}`;
        if (!document.querySelector(`.box[data-r="${br}"][data-c="${bc}"]`).classList.contains(`player-${playerNum}`)) {
          document.querySelector(`.box[data-r="${br}"][data-c="${bc}"]`).classList.add(`player-${playerNum}`);
          completed++;
        }
      }
    });

    return completed;
  }

  // Check if a box is completed (4 surrounding lines taken)
  function isBoxCompleted(r, c) {
    // lines at: top (r-1,c), bottom (r+1,c), left (r,c-1), right (r,c+1)
    const requiredLines = [
      [r - 1, c],
      [r + 1, c],
      [r, c - 1],
      [r, c + 1],
    ];
    return requiredLines.every(([lr, lc]) => lines.has(`${lr},${lc}`));
  }

  // Render boxes colors based on scores
  function renderBoxes() {
    const boxes = document.querySelectorAll('.box');
    boxes.forEach(box => {
      if (!box.classList.contains('player-1') && !box.classList.contains('player-2') && !box.classList.contains('player-3') && !box.classList.contains('player-4')) {
        box.classList.remove('player-1', 'player-2', 'player-3', 'player-4');
      }
    });
  }

  // Check if game is over
  function checkGameOver() {
    const totalBoxes = boardSize * boardSize;
    let filledBoxes = 0;
    players.forEach((_, idx) => {
      if (scores[idx]) filledBoxes += scores[idx];
    });
    if (filledBoxes >= totalBoxes) {
      isGameOver = true;
      announceWinner();
      btnRestart.classList.remove('hidden');
      gameActive = false;
      statusDiv.textContent = '';
      return true;
    }
    return false;
  }

  // Announce winner by score
  function announceWinner() {
    let maxScore = -1;
    let winners = [];
    players.forEach((_, idx) => {
      if ((scores[idx] || 0) > maxScore) {
        maxScore = scores[idx] || 0;
        winners = [idx];
      } else if ((scores[idx] || 0) === maxScore) {
        winners.push(idx);
      }
    });

    if (winners.length === 1) {
      const winnerText = winners[0] === players.indexOf(currentUser.uid) ? 'You won!' : `Player ${winners[0] + 1} won!`;
      winnerMessage.textContent = winnerText;
      // Update rating for current user if playing online (optional)
      if (!isBotMode && currentUser && players.includes(currentUser.uid)) {
        const yourIndex = players.indexOf(currentUser.uid);
        if (winners[0] === yourIndex) {
          updateUserRating(currentUser.uid, +10);
        } else {
          updateUserRating(currentUser.uid, -10);
        }
      }
    } else {
      winnerMessage.textContent = "It's a tie!";
    }
  }

  // Save current game state to Firebase
  function saveGameState() {
    if (!slotCode) return;
    const state = {
      lines: Array.from(lines),
      scores,
      currentTurn,
      players,
      isBotMode,
      isGameOver,
    };
    db.ref(`matches/${slotCode}`).set(state);
  }

  // Load game state from Firebase for this slot
  function loadGameState(snapshot) {
    const state = snapshot.val();
    if (!state) return;

    lines = new Set(state.lines || []);
    scores = state.scores || {};
    currentTurn = state.currentTurn || 0;
    players = state.players || [];
    isBotMode = state.isBotMode || false;
    isGameOver = state.isGameOver || false;

    updateBoardFromState();
    renderPlayerList();
    updateStatus();

    if (isGameOver) {
      announceWinner();
      btnRestart.classList.remove('hidden');
      gameActive = false;
    } else {
      gameActive = true;
      btnRestart.classList.add('hidden');
    }
  }

  // Update board UI from state
  function updateBoardFromState() {
    // Reset lines & boxes classes
    document.querySelectorAll('.line').forEach(line => {
      line.classList.remove('active', 'player-1', 'player-2', 'player-3', 'player-4');
      line.style.cursor = 'pointer';
    });
    document.querySelectorAll('.box').forEach(box => {
      box.classList.remove('player-1', 'player-2', 'player-3', 'player-4');
    });

    // Mark lines
    lines.forEach(key => {
      const [r, c] = key.split(',');
      const selector = `.line[data-r="${r}"][data-c="${c}"]`;
      const line = document.querySelector(selector);
      if (line) {
        line.classList.add('active');
        // Find who played this line based on surrounding boxes ownership is tricky,
        // so just color it with the player's color that last played the line (approximate)
        // For simplicity, do not recolor lines by player here.
        line.style.cursor = 'default';
      }
    });

    // Mark boxes
    for (const key in scores) {
      // Not necessary here because we mark box ownership by class
    }
    // Mark boxes ownership by scanning each box:
    document.querySelectorAll('.box').forEach(box => {
      const r = +box.dataset.r;
      const c = +box.dataset.c;
      for (let p = 0; p < players.length; p++) {
        // If box has class player-p, keep it (to simplify we reassign below)
        box.classList.remove('player-1', 'player-2', 'player-3', 'player-4');
      }
    });
    // Re-check ownership for each box (brute force)
    for (let r = 1; r < boardSize * 2 - 1; r += 2) {
      for (let c = 1; c < boardSize * 2 - 1; c += 2) {
        for (let p = 0; p < players.length; p++) {
          if (isBoxCompleted(r, c)) {
            const boxElem = document.querySelector(`.box[data-r="${r}"][data-c="${c}"]`);
            if (boxElem && !boxElem.classList.contains(`player-${p + 1}`)) {
              boxElem.classList.add(`player-${p + 1}`);
            }
          }
        }
      }
    }
  }

  // Start new online match with chosen mode
  async function startMatch(mode, withBot = false) {
    resetGame();
    currentMode = mode;
    isBotMode = withBot;
    gameActive = true;
    isGameOver = false;

    // Prepare players array
    players = [];

    if (withBot) {
      // Current user + bot(s)
      players.push(currentUser.uid);
      const botCount = mode - 1;
      for (let i = 0; i < botCount; i++) players.push('bot');
    } else {
      // Only current user first, others join later
      players.push(currentUser.uid);
    }

    renderPlayerList();
    updateStatus();

    // Generate slot code & save initial state
    slotCode = generateCode();
    matchInfo.textContent = `Match Code: ${slotCode}`;
    slotRef = db.ref(`matches/${slotCode}`);
    await slotRef.set({
      lines: [],
      scores: {},
      currentTurn: 0,
      players,
      isBotMode: withBot,
      isGameOver: false,
    });

    // Listen to slot updates
    if (slotListener) slotRef.off('value', slotListener);
    slotListener = slotRef.on('value', snapshot => {
      if (!gameActive) return;
      loadGameState(snapshot);
    });

    // If 2 or 4 player mode without bot, join matchmaking to find opponents
    if (!withBot && (mode === 2 || mode === 4)) {
      joinMatchmaking(slotCode, mode);
    } else if (withBot) {
      // Bot starts immediately if it's bot mode and bot's turn
      if (players[currentTurn] === 'bot') {
        setTimeout(botPlay, 1200);
      }
    }
  }

  // Join matchmaking queue and wait for opponents
  function joinMatchmaking(code, mode) {
    const queueRef = db.ref(`queue/mode${mode}`);

    // Add current user to queue
    queueRef.child(currentUser.uid).set({ code, timestamp: Date.now() });

    // Listen for other players in queue to form a match
    queueRef.on('value', snapshot => {
      if (!gameActive) return;
      const playersInQueue = Object.keys(snapshot.val() || {});
      if (playersInQueue.length >= mode) {
        // Form match
        const matchPlayers = playersInQueue.slice(0, mode);
        // Only proceed if current user in matchPlayers
        if (!matchPlayers.includes(currentUser.uid)) return;

        // Remove players from queue
        matchPlayers.forEach(p => queueRef.child(p).remove());

        // Update players array & save to Firebase
        players = matchPlayers;
        currentTurn = 0;
        isGameOver = false;
        isBotMode = false;
        gameActive = true;

        renderPlayerList();
        updateStatus();

        slotRef.set({
          lines: [],
          scores: {},
          currentTurn: 0,
          players,
          isBotMode: false,
          isGameOver: false,
        });
        matchInfo.textContent = `Match Code: ${slotCode} | Players: ${players.map(p => (p === currentUser.uid ? 'You' : 'Player')).join(', ')}`;
      }
    });
  }

  // Bot play logic: simple random available line
  function botPlay() {
    if (!gameActive || isGameOver) return;
    if (players[currentTurn] !== 'bot') return;

    const availableLines = [];
    document.querySelectorAll('.line').forEach(line => {
      const key = `${line.dataset.r},${line.dataset.c}`;
      if (!lines.has(key) && !line.classList.contains('active')) {
        availableLines.push(line);
      }
    });

    if (availableLines.length === 0) return;

    const chosenLine = availableLines[Math.floor(Math.random() * availableLines.length)];
    chosenLine.click();
  }

  // Restart button
  btnRestart.addEventListener('click', () => {
    if (slotCode) {
      slotRef.remove();
      slotCode = null;
      resetGame();
    }
  });

  // Mode buttons
  btnMode2.addEventListener('click', () => startMatch(2, false));
  btnMode4.addEventListener('click', () => startMatch(4, false));
  btnContinueBot.addEventListener('click', () => {
    modal.classList.add('active');
  });

  modalBtnContinue.addEventListener('click', () => {
    modal.classList.remove('active');
    startMatch(currentMode, true);
  });

  modalBtnCancel.addEventListener('click', () => {
    modal.classList.remove('active');
  });

  // Reset whole app (sign out)
  function resetApp() {
    clearSlot();
    authScreen.classList.remove('hidden');
    app.classList.add('hidden');
  }

  // Leaderboard loading & rendering
  async function loadLeaderboard() {
    const leaderboardRef = db.ref('users');
    leaderboardRef.off();
    leaderboardRef.on('value', snapshot => {
      const data = snapshot.val() || {};
      const arr = Object.entries(data).map(([uid, info]) => ({
        uid,
        name: info.name || 'Anonymous',
        rating: info.rating || 1000,
      }));
      arr.sort((a, b) => b.rating - a.rating);

      const leaderboardDiv = document.getElementById('leaderboard');
      leaderboardDiv.innerHTML = '';
      arr.forEach((user, idx) => {
        const div = document.createElement('div');
        div.className = 'flex justify-between p-1 text-sm border-b border-gray-700';
        div.innerHTML = `<span>${idx + 1}. ${user.name}</span><span>${user.rating}</span>`;
        leaderboardDiv.appendChild(div);
      });
    });

    // Also save/update current user info in DB
    if (currentUser) {
      const userRef = db.ref(`users/${currentUser.uid}`);
      userRef.update({
        name: currentUser.displayName || 'Anonymous',
        photoURL: currentUser.photoURL || '',
        lastSeen: Date.now(),
        rating: firebase.database.ServerValue.increment(0), // Ensure rating exists
      });
    }
  }
</script>

</body>
</html>
