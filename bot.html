<!DOCTYPE html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8" />  
  <meta name="viewport" content="width=device-width, initial-scale=1" />  
  <title>Dot and Box Game (Play vs Smart Bot)</title>  
  <link rel="icon" type="image/png" href="favicon.png">  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>  
  <style>  
    body {  
      font-family: Arial, sans-serif;  
      text-align: center;  
      margin: 0;  
      background-color: #121212;  
      color: #ffffff;  
    }  
    h1 {  
      margin-top: 20px;  
    }  
    #game-board {  
      display: grid;  
      gap: 5px;  
      margin: 20px auto;  
      width: 350px;  
    }  
    .dot {  
      width: 12px;  
      height: 12px;  
      background-color: #ffffff;  
      border-radius: 50%;  
    }  
    .line {  
      background-color: #444;  
      cursor: pointer;  
      transition: background-color 0.2s;  
    }  
    .line.horizontal {  
      height: 6px;  
      width: 60px;  
    }  
    .line.vertical {  
      height: 60px;  
      width: 6px;  
    }  
    .line.active {  
      background-color: #00ff00;  
      cursor: default;  
    }  
    .box {  
      width: 60px;  
      height: 60px;  
      background-color: #2a2a2a;  
      display: flex;  
      align-items: center;  
      justify-content: center;  
      font-size: 1.2em;  
      font-weight: bold;  
      color: #ffffff;  
      user-select: none;  
    }  
    .player-1 {  
      background-color: #4a90e2; /* Blue */  
    }  
    .player-2 {  
      background-color: #e94e77; /* Red */  
    }  
    #status {  
      margin: 20px 0;  
      font-size: 1.5em;  
      font-weight: bold;  
      display: inline-block;  
      padding: 10px 20px;  
      border-radius: 5px;  
    }  
    .blue-turn {  
      background-color: #4a90e2;  
      color: white;  
    }  
    .red-turn {  
      background-color: #e94e77;  
      color: white;  
    }  
    #winner-message {  
      margin: 20px 0;  
      font-size: 1.5em;  
      font-weight: bold;  
      color: #00ff00;  
    }  
    #restart {  
      margin-top: 20px;  
      padding: 10px 20px;  
      font-size: 16px;  
      background-color: #555;  
      border: none;  
      color: white;  
      cursor: pointer;  
      border-radius: 5px;  
    }  
    #restart:hover {  
      background-color: #777;  
    }  
  </style>  
</head>  
<body>  
  <h1>Dot and Box Game (Play vs Smart Bot)</h1>  
  <div id="status" class="animate__animated animate__pulse blue-turn">Player 1's turn (Blue)</div>  
  <div id="winner-message"></div>  
  <div id="game-board"></div>  
  <button id="restart">Restart Game</button>  
  
  <!-- Firebase -->  
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>  
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>  
  <script>  
    const firebaseConfig = {  
      apiKey: "AIzaSyCKfr-jvUKonc2TcEDcejk562kOm8LTAa0",  
      authDomain: "dot-and-box-online.firebaseapp.com",  
      databaseURL: "https://dot-and-box-online-default-rtdb.asia-southeast1.firebasedatabase.app",  
      projectId: "dot-and-box-online",  
      storageBucket: "dot-and-box-online.firebasestorage.app",  
      messagingSenderId: "334340725862",  
      appId: "1:334340725862:web:356b78d59e76ff6f5861a7"  
    };  
    firebase.initializeApp(firebaseConfig);  
    const db = firebase.database();  
  </script>  
  
  <script>  
    const boardSize = 5;  
    const gameBoard = document.getElementById("game-board");  
    const status = document.getElementById("status");  
    const winnerMessage = document.getElementById("winner-message");  
    const restartButton = document.getElementById("restart");  
    const victorySound = new Audio("Audio/correct-6033.mp3");  
  
    let currentPlayer = 1; // 1 = human (blue), 2 = bot (red)  
    let scores = { 1: 0, 2: 0 };  
    let lines = new Set();  
    let gameOver = false;  
  
    function createBoard() {  
      winnerMessage.textContent = "";  
      gameOver = false;  
      const gridTemplate = [];  
      for (let i = 0; i < boardSize * 2 - 1; i++) gridTemplate.push("auto");  
      gameBoard.style.gridTemplateColumns = gridTemplate.join(" ");  
      gameBoard.innerHTML = "";  
  
      for (let row = 0; row < boardSize * 2 - 1; row++) {  
        for (let col = 0; col < boardSize * 2 - 1; col++) {  
          if (row % 2 === 0 && col % 2 === 0) {  
            const dot = document.createElement("div");  
            dot.className = "dot";  
            gameBoard.appendChild(dot);  
          } else if (row % 2 === 0 || col % 2 === 0) {  
            const line = document.createElement("div");  
            line.className = `line ${row % 2 === 0 ? "horizontal" : "vertical"}`;  
            line.dataset.row = row;  
            line.dataset.col = col;  
            line.addEventListener("click", () => selectLine(row, col));  
            gameBoard.appendChild(line);  
          } else {  
            const box = document.createElement("div");  
            box.className = "box";  
            box.dataset.row = row;  
            box.dataset.col = col;  
            gameBoard.appendChild(box);  
          }  
        }  
      }  
    }  
  
    function selectLine(row, col) {  
      if (gameOver || currentPlayer !== 1) return;  
      const key = `${row}-${col}`;  
      if (lines.has(key)) return;  
  
      lines.add(key);  
      const el = document.querySelector(`.line[data-row="${row}"][data-col="${col}"]`);  
      el.classList.add("active");  
      el.style.backgroundColor = "#4a90e2";  
  
      const gotBox = checkForCompletedBoxes(row, col);  
  
      if (!gotBox) {  
        currentPlayer = 2;  
        updateStatus();  
        setTimeout(makeBotMove, 700);  
      } else {  
        updateStatus();  
      }  
  
      if (isGameOver()) declareWinner();  
    }  
  
    function checkForCompletedBoxes(row, col) {  
      let completed = false;  
      const tryBox = (r, c) => {  
        const top    = `${r-1}-${c}`, bottom = `${r+1}-${c}`,  
              left   = `${r}-${c-1}`, right  = `${r}-${c+1}`;  
        if ([top, bottom, left, right].every(l => lines.has(l))) {  
          const box = document.querySelector(`.box[data-row="${r}"][data-col="${c}"]`);  
          if (!box.classList.contains("player-1") && !box.classList.contains("player-2")) {  
            box.classList.add(currentPlayer === 1 ? "player-1" : "player-2");  
            box.textContent = currentPlayer;  
            scores[currentPlayer]++;  
            completed = true;  
          }  
        }  
      };  
      if (row % 2 === 0) {  
        tryBox(row-1, col);  
        tryBox(row+1, col);  
      } else {  
        tryBox(row, col-1);  
        tryBox(row, col+1);  
      }  
      return completed;  
    }  
  
    function updateStatus() {  
      if (gameOver) return;  
      status.textContent = `Player ${currentPlayer}'s turn (${currentPlayer===1?"Blue":"Red (Bot)"})`;  
      status.classList.remove("animate__pulse","blue-turn","red-turn");  
      void status.offsetWidth;  
      status.classList.add("animate__pulse", currentPlayer===1?"blue-turn":"red-turn");  
    }  
  
    function isGameOver() {  
      return scores[1] + scores[2] === (boardSize-1)*(boardSize-1);  
    }  
  
    function declareWinner() {  
      gameOver = true;  
      const winner = scores[1]>scores[2]?"Blue (You)":"Red (Bot)";  
      status.textContent = "";  
      winnerMessage.textContent = `${winner} is the winner!`;  
      victorySound.play();  
    }  
  
    function restartGame() {  
      lines.clear();  
      scores = {1:0,2:0};  
      currentPlayer = 1;  
      gameOver = false;  
      createBoard();  
      updateStatus();  
    }  
  
    restartButton.addEventListener("click", restartGame);  
  
    createBoard();  
    updateStatus();  
  
    // ==== Bot Logic: Smart Bot ====  
  
    // Check how many lines are connected to each box, helps detect 2 or 3 lines drawn  
    function countBoxLines(r, c) {  
      const top    = `${r-1}-${c}`, bottom = `${r+1}-${c}`,  
            left   = `${r}-${c-1}`, right  = `${r}-${c+1}`;  
      return [top, bottom, left, right].filter(l => lines.has(l)).length;  
    }  
  
    // Check if drawing a line creates 3 sides for any adjacent box  
    function moveCreatesThirdSide(r, c) {  
      let count = 0;  
      if (r % 2 === 0) {  
        // horizontal line => adjacent boxes above and below  
        if (r > 0 && countBoxLines(r-1, c) === 2) count++;  
        if (r < boardSize*2 - 2 && countBoxLines(r+1, c) === 2) count++;  
      } else {  
        // vertical line => adjacent boxes left and right  
        if (c > 0 && countBoxLines(r, c-1) === 2) count++;  
        if (c < boardSize*2 - 2 && countBoxLines(r, c+1) === 2) count++;  
      }  
      return count;  
    }  

    // Detect corner moves  
    function isCornerMove(row, col) {  
      const max = boardSize * 2 - 2;  
      return (row === 0 || row === max || col === 0 || col === max);  
    }  
  
    async function makeBotMove() {  
      if (gameOver) return;  
      currentPlayer = 2;  
      updateStatus();  
  
      const size = boardSize*2 - 1;  
      const allLines = [];  
      for (let r=0;r<size;r++) {  
        for (let c=0;c<size;c++) {  
          if ((r%2===0||c%2===0) && !(r%2===0 && c%2===0)) {  
            const key = `${r}-${c}`;  
            if (!lines.has(key)) allLines.push({row:r,col:c,key});  
          }  
        }  
      }  
      if (allLines.length === 0) {  
        currentPlayer = 1;  
        updateStatus();  
        return;  
      }  
  
      // Step 1: Find any winning move (completes box immediately)  
      for (const line of allLines) {  
        if (wouldCompleteBox(line.row, line.col)) {  
          await applyBotMove(line);  
          return;  
        }  
      }  
  
      // Step 2: Find safe moves (those that do NOT create boxes with 3 sides for opponent)  
      const safeMoves = allLines.filter(l => moveCreatesThirdSide(l.row, l.col) === 0);  
  
      // Step 3: If no safe moves, pick from moves with minimal risk (lowest count of creating 3-side boxes)  
      let candidateMoves = safeMoves.length > 0 ? safeMoves : allLines;  

      // Sort with corner penalty  
      candidateMoves.sort((a,b) => {  
        let scoreA = moveCreatesThirdSide(a.row, a.col);  
        let scoreB = moveCreatesThirdSide(b.row, b.col);  
  
        // Add penalty to corner moves  
        if (isCornerMove(a.row, a.col)) scoreA += 2;  
        if (isCornerMove(b.row, b.col)) scoreB += 2;  
  
        return scoreA - scoreB;  
      });  
  
      // Pick best candidate (lowest risk + corner penalty)  
      const choice = candidateMoves[0];  
  
      await applyBotMove(choice);  
    }  
  
    function wouldCompleteBox(row, col) {  
      // Check if drawing line at (row,col) completes any adjacent box  
      if (row % 2 === 0) {  
        // horizontal line => check box above and below  
        if (row > 0 && countBoxLines(row-1, col) === 3 && !boxClaimed(row-1, col)) return true;  
        if (row < boardSize*2-2 && countBoxLines(row+1, col) === 3 && !boxClaimed(row+1, col)) return true;  
      } else {  
        // vertical line => check box left and right  
        if (col > 0 && countBoxLines(row, col-1) === 3 && !boxClaimed(row, col-1)) return true;  
        if (col < boardSize*2-2 && countBoxLines(row, col+1) === 3 && !boxClaimed(row, col+1)) return true;  
      }  
      return false;  
    }  
  
    function boxClaimed(row, col) {  
      const box = document.querySelector(`.box[data-row="${row}"][data-col="${col}"]`);  
      return box.classList.contains("player-1") || box.classList.contains("player-2");  
    }  
  
    async function applyBotMove(choice) {  
      lines.add(choice.key);  
      const el = document.querySelector(`.line[data-row="${choice.row}"][data-col="${choice.col}"]`);  
      if (el) {  
        el.classList.add("active");  
        el.style.backgroundColor = "#e94e77"; // Bot red  
      }  
  
      const gotBox = checkForCompletedBoxes(choice.row, choice.col);  
  
      // Update Firebase score for the line  
      try {  
        await db.ref(`lineStats/${choice.key}`).transaction(curr => {  
          if (curr === null) return {score: gotBox ? 1 : -1};  
          return {score: curr.score + (gotBox ? 1 : -1)};  
        });  
      } catch(e) {  
        console.error("Firebase update error:", e);  
      }  
  
      if (!gotBox) {  
        currentPlayer = 1;  
        updateStatus();  
      } else {  
        updateStatus();  
        // If bot scored, it gets another move after a delay  
        setTimeout(makeBotMove, 700);  
      }  
  
      if (isGameOver()) declareWinner();  
    }  
  
  document.addEventListener('contextmenu', event => event.preventDefault());  
  document.onkeydown = function(e) {  
    if(e.key === "F12" ||   
       (e.ctrlKey && e.shiftKey && ['I','J','C'].includes(e.key)) ||   
       (e.ctrlKey && e.key === 'U')) {  
      return false;  
    }  
  };  
  </script>  
</body>  
</html>
