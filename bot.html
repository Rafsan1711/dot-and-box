<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Dot and Box Game (Play vs Bot)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
  <style>
    /* --- (ওই আগের CSS অপরিবর্তিত) --- */
    body { font-family: Arial; text-align: center; margin: 0; background: #121212; color: #fff; }
    h1 { margin-top:20px; }
    #game-board { display:grid; gap:5px; margin:20px auto; width:350px; }
    .dot { width:12px; height:12px; background:#fff; border-radius:50%; }
    .line { background:#444; cursor:pointer; transition:background 0.2s; }
    .line.horizontal { height:6px; width:60px; }
    .line.vertical { height:60px; width:6px; }
    .line.active { background:#00ff00; cursor:default; }
    .box { width:60px; height:60px; background:#2a2a2a; display:flex; align-items:center; justify-content:center; font-size:1.2em; font-weight:bold; color:#fff; user-select:none; }
    .player-1 { background:#4a90e2; }
    .player-2 { background:#e94e77; }
    #status { margin:20px 0; font-size:1.5em; font-weight:bold; padding:10px 20px; border-radius:5px; display:inline-block; }
    .blue-turn { background:#4a90e2; color:#fff; }
    .red-turn { background:#e94e77; color:#fff; }
    #winner-message { margin:20px 0; font-size:1.5em; font-weight:bold; color:#0f0; }
    #restart { margin-top:20px; padding:10px 20px; font-size:16px; background:#555; border:none; color:#fff; cursor:pointer; border-radius:5px; }
    #restart:hover { background:#777; }
  </style>
</head>
<body>
  <h1>Dot and Box Game (Play vs Bot)</h1>
  <div id="status" class="animate__animated animate__pulse blue-turn">Player 1's turn (Blue)</div>
  <div id="winner-message"></div>
  <div id="game-board"></div>
  <button id="restart">Restart Game</button>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCKfr-jvUKonc2TcEDcejk562kOm8LTAa0",
      authDomain: "dot-and-box-online.firebaseapp.com",
      databaseURL: "https://dot-and-box-online-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "dot-and-box-online",
      storageBucket: "dot-and-box-online.firebasestorage.app",
      messagingSenderId: "334340725862",
      appId: "1:334340725862:web:356b78d59e76ff6f5861a7"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
  </script>

  <script>
    // --- Variables & Helpers ---
    const boardSize=5, gameBoard=document.getElementById("game-board");
    const status=document.getElementById("status"), winnerMessage=document.getElementById("winner-message");
    const restartBtn=document.getElementById("restart"), victorySound=new Audio("Audio/correct-6033.mp3");

    let currentPlayer=1, scores={1:0,2:0}, lines=new Set(), gameOver=false;

    function createBoard(){
      winnerMessage.textContent=""; gameOver=false; lines.clear();
      const cols=Array(boardSize*2-1).fill("auto").join(" ");
      gameBoard.style.gridTemplateColumns=cols; gameBoard.innerHTML="";
      for(let r=0;r<boardSize*2-1;r++){
        for(let c=0;c<boardSize*2-1;c++){
          if(r%2===0&&c%2===0){
            const dot=document.createElement("div"); dot.className="dot"; gameBoard.appendChild(dot);
          } else if(r%2===0||c%2===0){
            const line=document.createElement("div");
            line.className=`line ${r%2===0?"horizontal":"vertical"}`;
            line.dataset.row=r; line.dataset.col=c;
            line.addEventListener("click",()=>selectLine(r,c));
            gameBoard.appendChild(line);
          } else {
            const box=document.createElement("div");
            box.className="box"; box.dataset.row=r; box.dataset.col=c;
            gameBoard.appendChild(box);
          }
        }
      }
    }

    function selectLine(r,c){
      if(gameOver||currentPlayer!==1) return;
      const k=`${r}-${c}`; if(lines.has(k)) return;
      lines.add(k);
      const el=document.querySelector(`.line[data-row="${r}"][data-col="${c}"]`);
      el.classList.add("active"); el.style.backgroundColor="#4a90e2";
      const got=checkForCompletedBoxes(r,c);
      if(!got){currentPlayer=2;updateStatus();setTimeout(makeBotMove,700);} else updateStatus();
      if(isGameOver()) declareWinner();
    }

    function checkForCompletedBoxes(r,c){
      let comp=false;
      const ck=(x,y)=>{
        const t=`${x-1}-${y}`,b=`${x+1}-${y}`,l=`${x}-${y-1}`,ri=`${x}-${y+1}`;
        if([t,b,l,ri].every(e=>lines.has(e))){
          const box=document.querySelector(`.box[data-row="${x}"][data-col="${y}"]`);
          if(!box.classList.contains("player-1")&&!box.classList.contains("player-2")){
            box.classList.add(currentPlayer===1?"player-1":"player-2");
            box.textContent=currentPlayer; scores[currentPlayer]++; comp=true;
          }
        }
      };
      if(r%2===0){ ck(r-1,c); ck(r+1,c); }
      else{ ck(r,c-1); ck(r,c+1); }
      return comp;
    }

    function updateStatus(){
      if(gameOver) return;
      status.textContent=`Player ${currentPlayer}'s turn (${currentPlayer===1?"Blue":"Red (Bot)"})`;
      status.classList.remove("animate__pulse","blue-turn","red-turn");
      void status.offsetWidth;
      status.classList.add("animate__pulse", currentPlayer===1?"blue-turn":"red-turn");
    }

    function isGameOver(){
      return scores[1]+scores[2]===((boardSize-1)*(boardSize-1));
    }

    function declareWinner(){
      gameOver=true;
      const w=scores[1]>scores[2]?"Blue (You)":"Red (Bot)";
      status.textContent=""; winnerMessage.textContent=`${w} is the winner!`;
      victorySound.play();
    }

    restartBtn.addEventListener("click",()=>{
      createBoard(); scores={1:0,2:0}; currentPlayer=1; updateStatus();
    });

    createBoard(); updateStatus();

    // --- Minimax Helpers ---
    function cloneState(){
      return {
        lines: new Set([...lines]),
        scores: {...scores}
      };
    }
    function generateMoves(state){
      const m=[]; const size=boardSize*2-1;
      for(let r=0;r<size;r++)for(let c=0;c<size;c++){
        if((r%2===0||c%2===0)&&!(r%2===0&&c%2===0)){
          const k=`${r}-${c}`; if(!state.lines.has(k)) m.push({row:r,col:c,key:k});
        }
      } return m;
    }
    function applyMove(state,move,player){
      state.lines.add(move.key);
      // update score if box
      const got=checkStateBox(state,move.row,move.col,player);
      if(got) state.scores[player]++;
      return {state,got};
    }
    function checkStateBox(state,r,c,player){
      let comp=false;
      const ck=(x,y)=>{
        const t=`${x-1}-${y}`,b=`${x+1}-${y}`,l=`${x}-${y-1}`,ri=`${x}-${y+1}`;
        if([t,b,l,ri].every(e=>state.lines.has(e))) comp=true;
      };
      if(r%2===0){ ck(r-1,c); ck(r+1,c);} else{ ck(r,c-1); ck(r,c+1);}
      return comp;
    }
    function evaluateState(state){
      return state.scores[2]-state.scores[1];
    }
    function minimax(state,depth,alpha,beta,maximizing){
      if(depth===0||state.scores[1]+state.scores[2]===((boardSize-1)*(boardSize-1)))
        return evaluateState(state);
      const moves=generateMoves(state);
      if(maximizing){
        let maxEval=-Infinity;
        for(const m of moves){
          const copy={lines:new Set(state.lines),scores:{...state.scores}};
          const {state:st,got}=applyMove({lines:copy.lines,scores:copy.scores},m,2);
          const eval=minimax(st,got?depth:depth-1,alpha,beta,false);
          maxEval=Math.max(maxEval,eval);
          alpha=Math.max(alpha,eval);
          if(beta<=alpha) break;
        }
        return maxEval;
      } else {
        let minEval=Infinity;
        for(const m of moves){
          const copy={lines:new Set(state.lines),scores:{...state.scores}};
          const {state:st,got}=applyMove({lines:copy.lines,scores:copy.scores},m,1);
          const eval=minimax(st,got?depth:depth-1,alpha,beta,true);
          minEval=Math.min(minEval,eval);
          beta=Math.min(beta,eval);
          if(beta<=alpha) break;
        }
        return minEval;
      }
    }
    function findBestMove(){
      const state={lines:new Set(lines),scores:{...scores}};
      let best=null, bestVal=-Infinity;
      const moves=generateMoves(state);
      for(const m of moves){
        const copy={lines:new Set(state.lines),scores:{...state.scores}};
        const {state:st,got}=applyMove({lines:copy.lines,scores:copy.scores},m,2);
        const val=minimax(st,got?3:2,-Infinity,Infinity,false);
        if(val>bestVal){ bestVal=val; best=m; }
      }
      return best;
    }

    // --- Bot Move with DB + Minimax ---
    async function makeBotMove(){
      if(gameOver) return;
      currentPlayer=2; updateStatus();
      // get moves + stats not needed for minimax
      // 80% minimax, 20% random
      let choice;
      if(Math.random()<0.2){
        const all=generateMoves({lines,new Set(),scores});
        choice=all[Math.floor(Math.random()*all.length)];
      } else {
        choice=findBestMove();
      }
      // apply visually
      lines.add(choice.key);
      const el=document.querySelector(`.line[data-row="${choice.row}"][data-col="${choice.col}"]`);
      el.classList.add("active"); el.style.backgroundColor="#e94e77";

      const got=checkForCompletedBoxes(choice.row,choice.col);
      // update DB score
      try{ await db.ref(`lineStats/${choice.key}`).transaction(c=>{
        if(c===null) return{score:got?1:-1};
        return{score:c.score+(got?1:-1)};
      });}catch(e){console.error(e);}
      if(!got){ currentPlayer=1; updateStatus(); }
      else{ updateStatus(); setTimeout(makeBotMove,700); }
      if(isGameOver()) declareWinner();
    }
  </script>
</body>
</html>
